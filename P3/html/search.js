window.pdocSearch = (function(){
/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();
    /** pdoc search index */const docs = [{"fullname": "arp", "modulename": "arp", "kind": "module", "doc": "<p>arp.py\nImplementaci\u00f3n del protocolo ARP y funciones auxiliares que permiten realizar resoluciones de direcciones IP.\nAutor: Alejandro Ra\u00fal Hurtado <a href=\"&#x6d;&#97;&#105;&#108;&#116;&#111;&#x3a;&#x61;&#x6c;&#x65;&#x6a;&#97;&#x6e;&#x64;&#114;&#111;&#114;.&#104;&#117;&#x72;&#x74;&#x61;&#100;&#111;&#64;&#x65;s&#116;&#x75;d&#105;&#97;&#x6e;&#116;&#101;&#46;&#117;&#97;&#x6d;&#46;&#101;&#x73;\">&#x61;&#x6c;&#x65;&#x6a;&#97;&#x6e;&#x64;&#114;&#111;&#114;.&#104;&#117;&#x72;&#x74;&#x61;&#100;&#111;&#64;&#x65;s&#116;&#x75;d&#105;&#97;&#x6e;&#116;&#101;&#46;&#117;&#97;&#x6d;&#46;&#101;&#x73;</a>\nAutor: Camilo Jen\u00e9 Conde <a href=\"&#x6d;&#97;&#105;l&#x74;&#111;&#x3a;&#99;a&#109;&#x69;&#108;&#x6f;&#x2e;jen&#101;&#99;&#64;&#x65;s&#x74;&#x75;&#x64;&#x69;&#97;&#x6e;&#116;&#101;&#46;&#117;&#x61;m&#46;&#101;&#115;\">&#99;a&#109;&#x69;&#108;&#x6f;&#x2e;jen&#101;&#99;&#64;&#x65;s&#x74;&#x75;&#x64;&#x69;&#97;&#x6e;&#116;&#101;&#46;&#117;&#x61;m&#46;&#101;&#115;</a>\n2022 EPS-UAM</p>\n"}, {"fullname": "arp.getIP", "modulename": "arp", "qualname": "getIP", "kind": "function", "doc": "<p>Nombre: getIP\nDescripci\u00f3n: Esta funci\u00f3n obtiene la direcci\u00f3n IP asociada a una interfaz. Esta funci\u00f3 NO debe ser modificada\nArgumentos:\n    -interface: nombre de la interfaz\nRetorno: Entero de 32 bits con la direcci\u00f3n IP de la interfaz</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">interface</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">int</span>:</span></span>", "funcdef": "def"}, {"fullname": "arp.printCache", "modulename": "arp", "qualname": "printCache", "kind": "function", "doc": "<p>Nombre: printCache\nDescripci\u00f3n: Esta funci\u00f3n imprime la cach\u00e9 ARP\nArgumentos: Ninguno\nRetorno: Ninguno</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "arp.processARPRequest", "modulename": "arp", "qualname": "processARPRequest", "kind": "function", "doc": "<p>Nombre: processARPRequest\nDecripci\u00f3n: Esta funci\u00f3n procesa una petici\u00f3n ARP. Esta funci\u00f3n debe realizar, al menos, las siguientes tareas:\n    -Extraer la MAC origen contenida en la petici\u00f3n ARP\n    -Si la MAC origen de la trama ARP no es la misma que la recibida del nivel Ethernet retornar\n    -Extraer la IP origen contenida en la petici\u00f3n ARP\n    -Extraer la IP destino contenida en la petici\u00f3n ARP\n    -Comprobar si la IP destino de la petici\u00f3n ARP es la propia IP:\n        -Si no es la propia IP retornar\n        -Si es la propia IP:\n            -Construir una respuesta ARP llamando a createARPReply (descripci\u00f3n m\u00e1s adelante)\n            -Enviar la respuesta ARP usando el nivel Ethernet (sendEthernetFrame)\nArgumentos:\n    -data: bytearray con el contenido de la trama ARP (despu\u00e9s de la cabecera com\u00fan)\n    -MAC: direcci\u00f3n MAC origen extra\u00edda por el nivel Ethernet\nRetorno: Ninguno</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">data</span><span class=\"p\">:</span> <span class=\"nb\">bytes</span>, </span><span class=\"param\"><span class=\"n\">MAC</span><span class=\"p\">:</span> <span class=\"nb\">bytes</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "arp.processARPReply", "modulename": "arp", "qualname": "processARPReply", "kind": "function", "doc": "<p>Nombre: processARPReply\nDecripci\u00f3n: Esta funci\u00f3n procesa una respuesta ARP. Esta funci\u00f3n debe realizar, al menos, las siguientes tareas:\n    -Extraer la MAC origen contenida en la petici\u00f3n ARP\n    -Si la MAC origen de la trama ARP no es la misma que la recibida del nivel Ethernet retornar\n    -Extraer la IP origen contenida en la petici\u00f3n ARP\n    -Extraer la MAC destino contenida en la petici\u00f3n ARP\n    -Extraer la IP destino contenida en la petici\u00f3n ARP\n    -Comprobar si la IP destino de la petici\u00f3n ARP es la propia IP:\n        -Si no es la propia IP retornar\n        -Si es la propia IP:\n            -Comprobar si la IP origen se corresponde con la solicitada (requestedIP). Si no se corresponde retornar\n            -Copiar la MAC origen a la variable global resolvedMAC\n            -A\u00f1adir a la cach\u00e9 ARP la asociaci\u00f3n MAC/IP.\n            -Cambiar el valor de la variable awaitingResponse a False\n            -Cambiar el valor de la variable requestedIP a None\nLas variables globales (requestedIP, awaitingResponse y resolvedMAC) son accedidas concurrentemente por la funci\u00f3n ARPResolution y deben ser protegidas mediante un Lock.\nArgumentos:\n    -data: bytearray con el contenido de la trama ARP (despu\u00e9s de la cabecera com\u00fan)\n    -MAC: direcci\u00f3n MAC origen extra\u00edda por el nivel Ethernet\nRetorno: Ninguno</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">data</span><span class=\"p\">:</span> <span class=\"nb\">bytes</span>, </span><span class=\"param\"><span class=\"n\">MAC</span><span class=\"p\">:</span> <span class=\"nb\">bytes</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "arp.createARPRequest", "modulename": "arp", "qualname": "createARPRequest", "kind": "function", "doc": "<p>Nombre: createARPRequest\nDescripci\u00f3n: Esta funci\u00f3n construye una petici\u00f3n ARP y devuelve la trama con el contenido.\nArgumentos: \n    -ip: direcci\u00f3n a resolver \nRetorno: Bytes con el contenido de la trama de petici\u00f3n ARP</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">ip</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bytes</span>:</span></span>", "funcdef": "def"}, {"fullname": "arp.createARPReply", "modulename": "arp", "qualname": "createARPReply", "kind": "function", "doc": "<p>Nombre: createARPReply\nDescripci\u00f3n: Esta funci\u00f3n construye una respuesta ARP y devuelve la trama con el contenido.\nArgumentos: \n    -IP: direcci\u00f3n IP a la que contestar\n    -MAC: direcci\u00f3n MAC a la que contestar\nRetorno: Bytes con el contenido de la trama de petici\u00f3n ARP</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">IP</span><span class=\"p\">:</span> <span class=\"nb\">int</span>, </span><span class=\"param\"><span class=\"n\">MAC</span><span class=\"p\">:</span> <span class=\"nb\">bytes</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bytes</span>:</span></span>", "funcdef": "def"}, {"fullname": "arp.process_arp_frame", "modulename": "arp", "qualname": "process_arp_frame", "kind": "function", "doc": "<p>Nombre: process_arp_frame\nDescripci\u00f3n: Esta funci\u00f3n procesa las tramas ARP. \n    Se ejecutar\u00e1 por cada trama Ethenet que se reciba con Ethertype 0x0806 (si ha sido registrada en initARP). \n    Esta funci\u00f3n debe realizar, al menos, las siguientes tareas:\n        -Extraer la cabecera com\u00fan de ARP (6 primeros bytes) y comprobar que es correcta\n        -Extraer el campo opcode\n        -Si opcode es 0x0001 (Request) llamar a processARPRequest (ver descripci\u00f3n m\u00e1s adelante)\n        -Si opcode es 0x0002 (Reply) llamar a processARPReply (ver descripci\u00f3n m\u00e1s adelante)\n        -Si es otro opcode retornar de la funci\u00f3n\n        -En caso de que no exista retornar\nArgumentos:\n    -us: Datos de usuario pasados desde la llamada de pcap_loop. En nuestro caso ser\u00e1 None\n    -header: cabecera pcap_pktheader\n    -data: array de bytes con el contenido de la trama ARP\n    -srcMac: MAC origen de la trama Ethernet que se ha recibido\nRetorno: Ninguno</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">us</span><span class=\"p\">:</span> <span class=\"n\">ctypes</span><span class=\"o\">.</span><span class=\"n\">c_void_p</span>,</span><span class=\"param\">\t<span class=\"n\">header</span><span class=\"p\">:</span> <span class=\"n\">rc1_pcap</span><span class=\"o\">.</span><span class=\"n\">pcap_pkthdr</span>,</span><span class=\"param\">\t<span class=\"n\">data</span><span class=\"p\">:</span> <span class=\"nb\">bytes</span>,</span><span class=\"param\">\t<span class=\"n\">srcMac</span><span class=\"p\">:</span> <span class=\"nb\">bytes</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "arp.initARP", "modulename": "arp", "qualname": "initARP", "kind": "function", "doc": "<p>Nombre: initARP\nDescripci\u00f3n: Esta funci\u00f3n construir\u00e1 inicializar\u00e1 el nivel ARP. Esta funci\u00f3n debe realizar, al menos, las siguientes tareas:\n    -Registrar la funci\u00f3n del callback process_arp_frame con el Ethertype 0x0806\n    -Obtener y almacenar la direcci\u00f3n MAC e IP asociadas a la interfaz especificada\n    -Realizar una petici\u00f3n ARP gratuita y comprobar si la IP propia ya est\u00e1 asignada. En caso positivo se debe devolver error.\n    -Marcar la variable de nivel ARP inicializado a True</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">interface</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">int</span>:</span></span>", "funcdef": "def"}, {"fullname": "arp.ARPResolution", "modulename": "arp", "qualname": "ARPResolution", "kind": "function", "doc": "<p>Nombre: ARPResolution\nDescripci\u00f3n: Esta funci\u00f3n intenta realizar una resoluci\u00f3n ARP para una IP dada y devuelve la direcci\u00f3n MAC asociada a dicha IP \n    o None en caso de que no haya recibido respuesta. Esta funci\u00f3n debe realizar, al menos, las siguientes tareas:\n        -Comprobar si la IP solicitada existe en la cach\u00e9:\n        -Si est\u00e1 en cach\u00e9 devolver la informaci\u00f3n de la cach\u00e9\n        -Si no est\u00e1 en la cach\u00e9:\n            -Construir una petici\u00f3n ARP llamando a la funci\u00f3n createARPRequest (descripci\u00f3n m\u00e1s adelante)\n            -Enviar dicha petici\u00f3n\n            -Comprobar si se ha recibido respuesta o no:\n                -Si no se ha recibido respuesta reenviar la petici\u00f3n hasta un m\u00e1ximo de 3 veces. Si no se recibe respuesta devolver None\n                -Si se ha recibido respuesta devolver la direcci\u00f3n MAC\n    Esta funci\u00f3n necesitar\u00e1 comunicarse con el la funci\u00f3n de recepci\u00f3n (para comprobar si hay respuesta y la respuesta en s\u00ed) mediante 3 variables globales:\n        -awaitingResponse: indica si est\u00e1 True que se espera respuesta. Si est\u00e1 a False quiere decir que se ha recibido respuesta\n        -requestedIP: contiene la IP por la que se est\u00e1 preguntando\n        -resolvedMAC: contiene la direcci\u00f3n MAC resuelta (en caso de que awaitingResponse) sea False.\n    Como estas variables globales se leen y escriben concurrentemente deben ser protegidas con un Lock</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">ip</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bytes</span>:</span></span>", "funcdef": "def"}, {"fullname": "ethernet", "modulename": "ethernet", "kind": "module", "doc": "<p>ethernet.py\nImplementaci\u00f3n del nivel Ethernet y funciones auxiliares para el env\u00edo y recepci\u00f3n de tramas Ethernet\nAutor: Alejandro Ra\u00fal Hurtado <a href=\"&#x6d;&#97;&#x69;l&#x74;&#111;&#58;&#97;&#x6c;&#x65;&#106;&#x61;&#110;&#100;&#x72;&#x6f;&#114;&#46;&#104;&#x75;&#114;t&#x61;&#100;o&#64;&#x65;&#115;&#x74;&#x75;&#100;&#105;&#97;&#x6e;&#116;&#101;&#x2e;u&#x61;&#x6d;&#x2e;&#101;s\">&#97;&#x6c;&#x65;&#106;&#x61;&#110;&#100;&#x72;&#x6f;&#114;&#46;&#104;&#x75;&#114;t&#x61;&#100;o&#64;&#x65;&#115;&#x74;&#x75;&#100;&#105;&#97;&#x6e;&#116;&#101;&#x2e;u&#x61;&#x6d;&#x2e;&#101;s</a>\nAutor: Camilo Jen\u00e9 Conde <a href=\"&#109;&#97;&#105;&#108;&#116;&#111;&#x3a;&#99;&#97;&#109;&#x69;&#108;&#111;&#x2e;&#x6a;&#101;&#110;&#101;&#99;&#x40;&#x65;&#x73;&#116;&#117;&#100;&#x69;&#97;&#x6e;&#x74;&#101;&#x2e;&#117;&#x61;&#x6d;&#46;&#101;&#x73;\">&#99;&#97;&#109;&#x69;&#108;&#111;&#x2e;&#x6a;&#101;&#110;&#101;&#99;&#x40;&#x65;&#x73;&#116;&#117;&#100;&#x69;&#97;&#x6e;&#x74;&#101;&#x2e;&#117;&#x61;&#x6d;&#46;&#101;&#x73;</a>\n2022 EPS-UAM</p>\n"}, {"fullname": "ethernet.getHwAddr", "modulename": "ethernet", "qualname": "getHwAddr", "kind": "function", "doc": "<p>Nombre: getHwAddr\nDescripci\u00f3n: Esta funci\u00f3n obtiene la direcci\u00f3n MAC asociada a una interfaz\nArgumentos:\n    -interface: Cadena con el nombre de la interfaz\nRetorno:\n    -Direcci\u00f3n MAC de la itnerfaz</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">interface</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ethernet.process_Ethernet_frame", "modulename": "ethernet", "qualname": "process_Ethernet_frame", "kind": "function", "doc": "<p>Nombre: process_Ethernet_frame\nDescripci\u00f3n: Esta funci\u00f3n se ejecutar\u00e1 cada vez que llegue una trama Ethernet. \n    Esta funci\u00f3n debe realizar, al menos, las siguientes tareas:\n        -Extraer los campos de direcci\u00f3n Ethernet destino, origen y ethertype\n        -Comprobar si la direcci\u00f3n destino es la propia o la de broadcast. En caso de que la trama no vaya en difusi\u00f3n o no sea para nuestra interfaz la descartaremos (haciendo un return).\n        -Comprobar si existe una funci\u00f3n de callback de nivel superior asociada al Ethertype de la trama:\n            -En caso de que exista, llamar a la funci\u00f3n de nivel superior con los par\u00e1metros que corresponde:\n                -us (datos de usuario)\n                -header (cabecera pcap_pktheader)\n                -payload (datos de la trama excluyendo la cabecera Ethernet)\n                -direcci\u00f3n Ethernet origen\n            -En caso de que no exista retornar\nArgumentos:\n    -us: datos de usuarios pasados desde pcap_loop (en nuestro caso ser\u00e1 None)\n    -header: estructura pcap_pkthdr que contiene los campos len, caplen y ts.\n    -data: bytearray con el contenido de la trama Ethernet\nRetorno:\n    -Ninguno</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">us</span><span class=\"p\">:</span> <span class=\"n\">ctypes</span><span class=\"o\">.</span><span class=\"n\">c_void_p</span>, </span><span class=\"param\"><span class=\"n\">header</span><span class=\"p\">:</span> <span class=\"n\">rc1_pcap</span><span class=\"o\">.</span><span class=\"n\">pcap_pkthdr</span>, </span><span class=\"param\"><span class=\"n\">data</span><span class=\"p\">:</span> <span class=\"nb\">bytes</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "ethernet.process_frame", "modulename": "ethernet", "qualname": "process_frame", "kind": "function", "doc": "<p>Nombre: process_frame\nDescripci\u00f3n: Esta funci\u00f3n se pasa a pcap_loop y se ejecutar\u00e1 cada vez que llegue una trama. La funci\u00f3n\nejecutar\u00e1 la funci\u00f3n process_Ethernet_frame en un hilo nuevo para evitar interbloqueos entre 2 recepciones\nconsecutivas de tramas dependientes. Esta funci\u00f3n NO debe modifciarse\nArgumentos:\n    -us: datos de usuarios pasados desde pcap_loop (en nuestro caso ser\u00e1 None)\n    -header: estructura pcap_pkthdr que contiene los campos len, caplen y ts.\n    -data: bytearray con el contenido de la trama Ethernet\nRetorno:\n    -Ninguno</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">us</span><span class=\"p\">:</span> <span class=\"n\">ctypes</span><span class=\"o\">.</span><span class=\"n\">c_void_p</span>, </span><span class=\"param\"><span class=\"n\">header</span><span class=\"p\">:</span> <span class=\"n\">rc1_pcap</span><span class=\"o\">.</span><span class=\"n\">pcap_pkthdr</span>, </span><span class=\"param\"><span class=\"n\">data</span><span class=\"p\">:</span> <span class=\"nb\">bytes</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "ethernet.rxThread", "modulename": "ethernet", "qualname": "rxThread", "kind": "class", "doc": "<p>Clase que implementa un hilo de recepci\u00f3n. De esta manera al iniciar el nivel Ethernet\npodemos dejar un hilo con pcap_loop que reciba los paquetes sin bloquear el env\u00edo.\nEn esta clase NO se debe modificar c\u00f3digo</p>\n", "bases": "threading.Thread"}, {"fullname": "ethernet.rxThread.__init__", "modulename": "ethernet", "qualname": "rxThread.__init__", "kind": "function", "doc": "<p>This constructor should always be called with keyword arguments. Arguments are:</p>\n\n<p><em>group</em> should be None; reserved for future extension when a ThreadGroup\nclass is implemented.</p>\n\n<p><em>target</em> is the callable object to be invoked by the run()\nmethod. Defaults to None, meaning nothing is called.</p>\n\n<p><em>name</em> is the thread name. By default, a unique name is constructed of\nthe form \"Thread-N\" where N is a small decimal number.</p>\n\n<p><em>args</em> is the argument tuple for the target invocation. Defaults to ().</p>\n\n<p><em>kwargs</em> is a dictionary of keyword arguments for the target\ninvocation. Defaults to {}.</p>\n\n<p>If a subclass overrides the constructor, it must make sure to invoke\nthe base class constructor (Thread.__init__()) before doing anything\nelse to the thread.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">()</span>"}, {"fullname": "ethernet.rxThread.run", "modulename": "ethernet", "qualname": "rxThread.run", "kind": "function", "doc": "<p>Method representing the thread's activity.</p>\n\n<p>You may override this method in a subclass. The standard run() method\ninvokes the callable object passed to the object's constructor as the\ntarget argument, if any, with sequential and keyword arguments taken\nfrom the args and kwargs arguments, respectively.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ethernet.rxThread.stop", "modulename": "ethernet", "qualname": "rxThread.stop", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ethernet.registerCallback", "modulename": "ethernet", "qualname": "registerCallback", "kind": "function", "doc": "<p>Nombre: registerCallback\nDescripci\u00f3n: Esta funci\u00f3n recibir\u00e1 el nombre de una funci\u00f3n y su valor de ethertype asociado y a\u00f1adir\u00e1 en la tabla \n    (diccionario) de protocolos de nivel superior el dicha asociaci\u00f3n. \n    Este mecanismo nos permite saber a qu\u00e9 funci\u00f3n de nivel superior debemos llamar al recibir una trama de determinado tipo. \n    Por ejemplo, podemos registrar una funci\u00f3n llamada process_IP_datagram asociada al Ethertype 0x0800 y otra llamada process_arp_packet \n    asocaida al Ethertype 0x0806. \nArgumentos:\n    -callback_fun: funci\u00f3n de callback a ejecutar cuando se reciba el Ethertype especificado. \n        La funci\u00f3n que se pase como argumento debe tener el siguiente prototipo: funcion(us,header,data,srcMac)\n        D\u00f3nde:\n            -us: son los datos de usuarios pasados por pcap_loop (en nuestro caso este valor ser\u00e1 siempre None)\n            -header: estructura pcap_pkthdr que contiene los campos len, caplen y ts.\n            -data: payload de la trama Ethernet. Es decir, la cabecera Ethernet NUNCA se pasa hacia arriba.\n            -srcMac: direcci\u00f3n MAC que ha enviado la trama actual.\n        La funci\u00f3n no retornar\u00e1 nada. Si una trama se quiere descartar basta con hacer un return sin valor y dejar\u00e1 de procesarse.\n    -ethertype: valor de Ethernetype para el cu\u00e1l se quiere registrar una funci\u00f3n de callback.\nRetorno: Ninguno</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">callback_func</span><span class=\"p\">:</span> <span class=\"n\">Callable</span><span class=\"p\">[[</span><span class=\"n\">ctypes</span><span class=\"o\">.</span><span class=\"n\">c_void_p</span><span class=\"p\">,</span> <span class=\"n\">rc1_pcap</span><span class=\"o\">.</span><span class=\"n\">pcap_pkthdr</span><span class=\"p\">,</span> <span class=\"nb\">bytes</span><span class=\"p\">],</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">ethertype</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "ethernet.startEthernetLevel", "modulename": "ethernet", "qualname": "startEthernetLevel", "kind": "function", "doc": "<p>Nombre: startEthernetLevel\nDescripci\u00f3n: Esta funci\u00f3n recibe el nombre de una interfaz de red e inicializa el nivel Ethernet. \n    Esta funci\u00f3n debe realizar , al menos, las siguientes tareas:\n        -Comprobar si el nivel Ethernet ya estaba inicializado (mediante una variable global). Si ya estaba inicializado devolver -1.\n        -Obtener y almacenar en una variable global la direcci\u00f3n MAC asociada a la interfaz que se especifica\n        -Abrir la interfaz especificada en modo promiscuo usando la librer\u00eda rc1-pcap\n        -Arrancar un hilo de recepci\u00f3n (rxThread) que llame a la funci\u00f3n pcap_loop. \n        -Si todo es correcto marcar la variable global de nivel incializado a True\nArgumentos:\n    -Interface: nombre de la interfaz sobre la que inicializar el nivel Ethernet\nRetorno: 0 si todo es correcto, -1 en otro caso</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">interface</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">int</span>:</span></span>", "funcdef": "def"}, {"fullname": "ethernet.stopEthernetLevel", "modulename": "ethernet", "qualname": "stopEthernetLevel", "kind": "function", "doc": "<p>Nombre: stopEthernetLevel\nDescripci\u00f3n_ Esta funci\u00f3n parar\u00e1 y liberar\u00e1 todos los recursos necesarios asociados al nivel Ethernet. \n    Esta funci\u00f3n debe realizar, al menos, las siguientes tareas:\n        -Parar el hilo de recepci\u00f3n de paquetes \n        -Cerrar la interfaz (handle de pcap)\n        -Marcar la variable global de nivel incializado a False\nArgumentos: Ninguno\nRetorno: 0 si todo es correcto y -1 en otro caso</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">) -> <span class=\"nb\">int</span>:</span></span>", "funcdef": "def"}, {"fullname": "ethernet.sendEthernetFrame", "modulename": "ethernet", "qualname": "sendEthernetFrame", "kind": "function", "doc": "<p>Nombre: sendEthernetFrame\nDescripci\u00f3n: Esta funci\u00f3n construir\u00e1 una trama Ethernet con lo datos recibidos y la enviar\u00e1 por la interfaz de red. \n    Esta funci\u00f3n debe realizar, al menos, las siguientes tareas:\n        -Construir la trama Ethernet a enviar (incluyendo cabecera + payload). Los campos propios (por ejemplo la direcci\u00f3n Ethernet origen) \n            deben obtenerse de las variables que han sido inicializadas en startEthernetLevel\n        -Comprobar los l\u00edmites de Ethernet. Si la trama es muy peque\u00f1a se debe rellenar con 0s mientras que \n            si es muy grande se debe devolver error.\n        -Llamar a pcap_inject para enviar la trama y comprobar el retorno de dicha llamada. En caso de que haya error notificarlo\nArgumentos:\n    -data: datos \u00fatiles o payload a encapsular dentro de la trama Ethernet\n    -length: longitud de los datos \u00fatiles expresada en bytes\n    -etherType: valor de tipo Ethernet a incluir en la trama\n    -dstMac: Direcci\u00f3n MAC destino a incluir en la trama que se enviar\u00e1\nRetorno: 0 si todo es correcto, -1 en otro caso</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">data</span><span class=\"p\">:</span> <span class=\"nb\">bytes</span>, </span><span class=\"param\"><span class=\"n\">length</span><span class=\"p\">:</span> <span class=\"nb\">int</span>, </span><span class=\"param\"><span class=\"n\">etherType</span><span class=\"p\">:</span> <span class=\"nb\">int</span>, </span><span class=\"param\"><span class=\"n\">dstMac</span><span class=\"p\">:</span> <span class=\"nb\">bytes</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">int</span>:</span></span>", "funcdef": "def"}, {"fullname": "icmp", "modulename": "icmp", "kind": "module", "doc": "<p>icmp.py</p>\n\n<p>Funciones necesarias para implementar el nivel ICMP</p>\n\n<p>Autor: Alejandro Ra\u00fal Hurtado <a href=\"&#x6d;&#97;i&#x6c;&#x74;&#x6f;&#x3a;&#97;&#x6c;&#x65;&#x6a;&#x61;&#x6e;&#100;&#x72;&#111;&#114;&#x2e;&#x68;&#x75;&#114;&#116;&#x61;&#100;o&#64;&#101;&#115;&#116;u&#x64;&#x69;&#x61;&#110;&#116;&#101;&#46;&#117;&#x61;&#109;.&#101;&#115;\">&#97;&#x6c;&#x65;&#x6a;&#x61;&#x6e;&#100;&#x72;&#111;&#114;&#x2e;&#x68;&#x75;&#114;&#116;&#x61;&#100;o&#64;&#101;&#115;&#116;u&#x64;&#x69;&#x61;&#110;&#116;&#101;&#46;&#117;&#x61;&#109;.&#101;&#115;</a>\nAutor: Camilo Jen\u00e9 Conde <a href=\"&#109;&#x61;&#x69;&#108;&#116;&#111;&#x3a;&#x63;&#x61;&#109;&#105;&#x6c;&#111;.j&#x65;&#110;&#x65;&#x63;&#64;es&#116;&#x75;&#100;&#105;&#x61;&#110;&#x74;e&#x2e;&#117;&#x61;&#109;&#x2e;&#101;&#x73;\">&#x63;&#x61;&#109;&#105;&#x6c;&#111;.j&#x65;&#110;&#x65;&#x63;&#64;es&#116;&#x75;&#100;&#105;&#x61;&#110;&#x74;e&#x2e;&#117;&#x61;&#109;&#x2e;&#101;&#x73;</a>\n2022 EPS-UAM</p>\n"}, {"fullname": "icmp.process_ICMP_message", "modulename": "icmp", "qualname": "process_ICMP_message", "kind": "function", "doc": "<p>Nombre: process_ICMP_message\nDescripci\u00f3n: Esta funci\u00f3n procesa un mensaje ICMP. Esta funci\u00f3n se ejecutar\u00e1 por cada datagrama IP que contenga\nun 1 en el campo protocolo de IP\nEsta funci\u00f3n debe realizar, al menos, las siguientes tareas:\n    -Calcular el checksum de ICMP y comprobar si es correcto:\n    -Extraer campos tipo y c\u00f3digo de la cabecera ICMP\n    -Loggear (con logging.debug) el valor de tipo y c\u00f3digo\n    -Si el tipo es ICMP_ECHO_REQUEST_TYPE:\n        -Generar un mensaje de tipo ICMP_ECHO_REPLY como respuesta. Este mensaje debe contener\n        los datos recibidos en el ECHO_REQUEST. Es decir, \"rebotamos\" los datos que nos llegan.\n        -Enviar el mensaje usando la funci\u00f3n sendICMPMessage\n    -Si el tipo es ICMP_ECHO_REPLY_TYPE:\n        -Extraer del diccionario icmp_send_times el valor de tiempo de env\u00edo usando como clave los campos srcIP e icmp_id e icmp_seqnum\n        contenidos en el mensaje ICMP. Restar el tiempo de envio extra\u00eddo con el tiempo de recepci\u00f3n (contenido en la estructura pcap_pkthdr)\n        -Se debe proteger el acceso al diccionario de tiempos usando la variable timeLock\n        -Mostrar por pantalla la resta. Este valor ser\u00e1 una estimaci\u00f3n del RTT\n    -Si es otro tipo:\n        -No hacer nada</p>\n\n<p>Argumentos:\n    -us: son los datos de usuarios pasados por pcap_loop (en nuestro caso este valor ser\u00e1 siempre None)\n    -header: estructura pcap_pkthdr que contiene los campos len, caplen y ts.\n    -data: array de bytes con el conenido del mensaje ICMP\n    -srcIP: direcci\u00f3n IP que ha enviado el datagrama actual.\nRetorno: Ninguno</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">us</span>, </span><span class=\"param\"><span class=\"n\">header</span>, </span><span class=\"param\"><span class=\"n\">data</span>, </span><span class=\"param\"><span class=\"n\">srcIp</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "icmp.sendICMPMessage", "modulename": "icmp", "qualname": "sendICMPMessage", "kind": "function", "doc": "<p>Nombre: sendICMPMessage\nDescripci\u00f3n: Esta funci\u00f3n construye un mensaje ICMP y lo env\u00eda.\nEsta funci\u00f3n debe realizar, al menos, las siguientes tareas:\n    -Si el campo type es ICMP_ECHO_REQUEST_TYPE o ICMP_ECHO_REPLY_TYPE:\n        -Construir la cabecera ICMP\n        -A\u00f1adir los datos al mensaje ICMP\n        -Calcular el checksum y a\u00f1adirlo al mensaje donde corresponda\n        -Si type es ICMP_ECHO_REQUEST_TYPE\n            -Guardar el tiempo de env\u00edo (llamando a time.time()) en el diccionario icmp_send_times\n            usando como clave el valor de dstIp+icmp_id+icmp_seqnum\n            -Se debe proteger al acceso al diccionario usando la variable timeLock</p>\n\n<pre><code>    -Llamar a sendIPDatagram para enviar el mensaje ICMP\n\n-Si no:\n    -Tipo no soportado. Se devuelve False\n</code></pre>\n\n<p>Argumentos:\n    -data: array de bytes con los datos a incluir como payload en el mensaje ICMP\n    -type: valor del campo tipo de ICMP\n    -code: valor del campo code de ICMP \n    -icmp_id: entero que contiene el valor del campo ID de ICMP a enviar\n    -icmp_seqnum: entero que contiene el valor del campo Seqnum de ICMP a enviar\n    -dstIP: entero de 32 bits con la IP destino del mensaje ICMP\nRetorno: True o False en funci\u00f3n de si se ha enviado el mensaje correctamente o no</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">data</span>, </span><span class=\"param\"><span class=\"nb\">type</span>, </span><span class=\"param\"><span class=\"n\">code</span>, </span><span class=\"param\"><span class=\"n\">icmp_id</span>, </span><span class=\"param\"><span class=\"n\">icmp_seqnum</span>, </span><span class=\"param\"><span class=\"n\">dstIP</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "icmp.initICMP", "modulename": "icmp", "qualname": "initICMP", "kind": "function", "doc": "<p>Nombre: initICMP\nDescripci\u00f3n: Esta funci\u00f3n inicializa el nivel ICMP\nEsta funci\u00f3n debe realizar, al menos, las siguientes tareas:\n    -Registrar (llamando a registerIPProtocol) la funci\u00f3n process_ICMP_message con el valor de protocolo 1</p>\n\n<p>Argumentos:\n    -Ninguno\nRetorno: Ninguno</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ip", "modulename": "ip", "kind": "module", "doc": "<p>ip.py</p>\n\n<p>Funciones necesarias para implementar el nivel IP</p>\n\n<p>Autor: Alejandro Ra\u00fal Hurtado <a href=\"&#109;&#x61;&#105;l&#x74;o&#58;&#x61;&#108;&#x65;&#x6a;&#97;n&#x64;&#x72;&#x6f;&#114;.&#104;&#117;&#114;&#116;&#x61;&#100;&#111;&#64;&#101;&#115;&#116;&#x75;&#100;&#x69;&#x61;&#x6e;&#116;&#101;&#x2e;&#x75;a&#x6d;&#46;&#101;&#x73;\">&#x61;&#108;&#x65;&#x6a;&#97;n&#x64;&#x72;&#x6f;&#114;.&#104;&#117;&#114;&#116;&#x61;&#100;&#111;&#64;&#101;&#115;&#116;&#x75;&#100;&#x69;&#x61;&#x6e;&#116;&#101;&#x2e;&#x75;a&#x6d;&#46;&#101;&#x73;</a>\nAutor: Camilo Jen\u00e9 Conde <a href=\"m&#x61;&#x69;&#108;&#116;&#111;&#58;&#99;&#97;&#109;&#x69;&#108;&#111;&#x2e;&#x6a;&#101;&#x6e;&#x65;&#99;&#64;e&#x73;&#116;&#117;&#100;&#105;&#97;&#x6e;&#x74;&#101;&#46;&#117;&#97;m&#46;&#x65;&#115;\">&#99;&#97;&#109;&#x69;&#108;&#111;&#x2e;&#x6a;&#101;&#x6e;&#x65;&#99;&#64;e&#x73;&#116;&#117;&#100;&#105;&#97;&#x6e;&#x74;&#101;&#46;&#117;&#97;m&#46;&#x65;&#115;</a>\n2022 EPS-UAM</p>\n"}, {"fullname": "ip.chksum", "modulename": "ip", "qualname": "chksum", "kind": "function", "doc": "<p>Nombre: chksum\nDescripci\u00f3n: Esta funci\u00f3n calcula el checksum IP sobre unos datos de entrada dados (msg)\nArgumentos:\n    -msg: array de bytes con el contenido sobre el que se calcular\u00e1 el checksum\nRetorno: Entero de 16 bits con el resultado del checksum en ORDEN DE RED</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">msg</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ip.getMTU", "modulename": "ip", "qualname": "getMTU", "kind": "function", "doc": "<p>Nombre: getMTU\nDescripci\u00f3n: Esta funci\u00f3n obteiene la MTU para un interfaz dada\nArgumentos:\n    -interface: cadena con el nombre la interfaz sobre la que consultar la MTU\nRetorno: Entero con el valor de la MTU para la interfaz especificada</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">interface</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ip.getNetmask", "modulename": "ip", "qualname": "getNetmask", "kind": "function", "doc": "<p>Nombre: getNetmask\nDescripci\u00f3n: Esta funci\u00f3n obteiene la m\u00e1scara de red asignada a una interfaz \nArgumentos:\n    -interface: cadena con el nombre la interfaz sobre la que consultar la m\u00e1scara\nRetorno: Entero de 32 bits con el valor de la m\u00e1scara de red</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">interface</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ip.getDefaultGW", "modulename": "ip", "qualname": "getDefaultGW", "kind": "function", "doc": "<p>Nombre: getDefaultGW\nDescripci\u00f3n: Esta funci\u00f3n obteiene el gateway por defecto para una interfaz dada\nArgumentos:\n    -interface: cadena con el nombre la interfaz sobre la que consultar el gateway\nRetorno: Entero de 32 bits con la IP del gateway</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">interface</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ip.process_IP_datagram", "modulename": "ip", "qualname": "process_IP_datagram", "kind": "function", "doc": "<p>Nombre: process_IP_datagram\nDescripci\u00f3n: Esta funci\u00f3n procesa datagramas IP recibidos.\n    Se ejecuta una vez por cada trama Ethernet recibida con Ethertype 0x0800\n    Esta funci\u00f3n debe realizar, al menos, las siguientes tareas:\n        -Extraer los campos de la cabecera IP (includa la longitud de la cabecera)\n        -Calcular el checksum y comprobar que es correcto <br />\n        -Analizar los bits de de MF y el offset. Si el offset tiene un valor != 0 dejar de procesar el datagrama (no vamos a reensamblar)\n        -Loggear (usando logging.debug) el valor de los siguientes campos:\n            -Longitud de la cabecera IP\n            -IPID\n            -TTL\n            -Valor de las banderas DF y MF\n            -Valor de offset\n            -IP origen y destino\n            -Protocolo\n        -Comprobar si tenemos registrada una funci\u00f3n de callback de nivel superior consultando el diccionario protocols y usando como\n        clave el valor del campo protocolo del datagrama IP.\n            -En caso de que haya una funci\u00f3n de nivel superior registrada, debe llamarse a dicha funci\u00f1\u00f3n \n            pasando los datos (payload) contenidos en el datagrama IP.</p>\n\n<p>Argumentos:\n    -us: Datos de usuario pasados desde la llamada de pcap_loop. En nuestro caso ser\u00e1 None\n    -header: cabecera pcap_pktheader\n    -data: array de bytes con el contenido del datagrama IP\n    -srcMac: MAC origen de la trama Ethernet que se ha recibido\nRetorno: Ninguno</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">us</span>, </span><span class=\"param\"><span class=\"n\">header</span>, </span><span class=\"param\"><span class=\"n\">data</span>, </span><span class=\"param\"><span class=\"n\">srcMac</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ip.registerIPProtocol", "modulename": "ip", "qualname": "registerIPProtocol", "kind": "function", "doc": "<p>Nombre: registerIPProtocol\nDescripci\u00f3n: Esta funci\u00f3n recibir\u00e1 el nombre de una funci\u00f3n y su valor de protocolo IP asociado y a\u00f1adir\u00e1 en la tabla \n    (diccionario) de protocolos de nivel superior dicha asociaci\u00f3n. \n    Este mecanismo nos permite saber a qu\u00e9 funci\u00f3n de nivel superior debemos llamar al recibir un datagrama IP  con un \n    determinado valor del campo protocolo (por ejemplo TCP o UDP).\n    Por ejemplo, podemos registrar una funci\u00f3n llamada process_UDP_datagram asociada al valor de protocolo 17 y otra \n    llamada process_ICMP_message asocaida al valor de protocolo 1. \nArgumentos:\n    -callback_fun: funci\u00f3n de callback a ejecutar cuando se reciba el protocolo especificado. \n        La funci\u00f3n que se pase como argumento debe tener el siguiente prototipo: funcion(us,header,data,srcIp):\n        D\u00f3nde:\n            -us: son los datos de usuarios pasados por pcap_loop (en nuestro caso este valor ser\u00e1 siempre None)\n            -header: estructura pcap_pkthdr que contiene los campos len, caplen y ts.\n            -data: payload del datagrama IP. Es decir, la cabecera IP NUNCA se pasa hacia arriba.\n            -srcIP: direcci\u00f3n IP que ha enviado el datagrama actual.\n        La funci\u00f3n no retornar\u00e1 nada. Si un datagrama se quiere descartar basta con hacer un return sin valor y dejar\u00e1 de procesarse.\n    -protocol: valor del campo protocolo de IP para el cu\u00e1l se quiere registrar una funci\u00f3n de callback.\nRetorno: Ninguno</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">callback</span>, </span><span class=\"param\"><span class=\"n\">protocol</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ip.initIP", "modulename": "ip", "qualname": "initIP", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">interface</span>, </span><span class=\"param\"><span class=\"n\">opts</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ip.sendIPDatagram", "modulename": "ip", "qualname": "sendIPDatagram", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">dstIP</span>, </span><span class=\"param\"><span class=\"n\">data</span>, </span><span class=\"param\"><span class=\"n\">protocol</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "udp", "modulename": "udp", "kind": "module", "doc": "<p>icmp.py</p>\n\n<p>Funciones necesarias para implementar el nivel UDP</p>\n\n<p>Autor: Alejandro Ra\u00fal Hurtado <a href=\"&#109;&#x61;&#x69;&#108;&#x74;&#111;&#58;&#97;l&#101;&#x6a;a&#110;&#100;&#114;&#111;&#x72;&#46;&#x68;&#x75;&#114;&#116;&#x61;&#x64;&#111;&#x40;e&#115;&#x74;u&#x64;&#x69;&#x61;&#110;&#116;&#101;&#46;&#117;&#97;&#x6d;&#x2e;&#x65;&#x73;\">&#97;l&#101;&#x6a;a&#110;&#100;&#114;&#111;&#x72;&#46;&#x68;&#x75;&#114;&#116;&#x61;&#x64;&#111;&#x40;e&#115;&#x74;u&#x64;&#x69;&#x61;&#110;&#116;&#101;&#46;&#117;&#97;&#x6d;&#x2e;&#x65;&#x73;</a>\nAutor: Camilo Jen\u00e9 Conde <a href=\"&#x6d;&#97;&#x69;&#108;&#x74;&#111;&#58;&#99;&#x61;&#x6d;&#x69;&#x6c;&#111;&#x2e;&#106;&#x65;n&#x65;&#x63;&#64;e&#x73;&#116;&#x75;&#100;&#x69;&#97;&#110;&#x74;&#x65;&#x2e;&#x75;&#x61;&#109;.&#x65;&#x73;\">&#99;&#x61;&#x6d;&#x69;&#x6c;&#111;&#x2e;&#106;&#x65;n&#x65;&#x63;&#64;e&#x73;&#116;&#x75;&#100;&#x69;&#97;&#110;&#x74;&#x65;&#x2e;&#x75;&#x61;&#109;.&#x65;&#x73;</a>\n2022 EPS-UAM</p>\n"}, {"fullname": "udp.getUDPSourcePort", "modulename": "udp", "qualname": "getUDPSourcePort", "kind": "function", "doc": "<p>Nombre: getUDPSourcePort\nDescripci\u00f3n: Esta funci\u00f3n obtiene un puerto origen libre en la m\u00e1quina actual.\nArgumentos:\n    -Ninguno\nRetorno: Entero de 16 bits con el n\u00famero de puerto origen disponible</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "udp.process_UDP_datagram", "modulename": "udp", "qualname": "process_UDP_datagram", "kind": "function", "doc": "<p>Nombre: process_UDP_datagram\nDescripci\u00f3n: Esta funci\u00f3n procesa un datagrama UDP. Esta funci\u00f3n se ejecutar\u00e1 por cada datagrama IP que contenga\nun 17 en el campo protocolo de IP\nEsta funci\u00f3n debe realizar, al menos, las siguientes tareas:\n    -Extraer los campos de la cabecera UDP\n    -Loggear (usando logging.debug) los siguientes campos:\n        -Puerto origen\n        -Puerto destino\n        -Datos contenidos en el datagrama UDP</p>\n\n<p>Argumentos:\n    -us: son los datos de usuarios pasados por pcap_loop (en nuestro caso este valor ser\u00e1 siempre None)\n    -header: estructura pcap_pkthdr que contiene los campos len, caplen y ts.\n    -data: array de bytes con el conenido del datagrama UDP\n    -srcIP: direcci\u00f3n IP que ha enviado el datagrama actual.\nRetorno: Ninguno</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">us</span>, </span><span class=\"param\"><span class=\"n\">header</span>, </span><span class=\"param\"><span class=\"n\">data</span>, </span><span class=\"param\"><span class=\"n\">srcIP</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "udp.sendUDPDatagram", "modulename": "udp", "qualname": "sendUDPDatagram", "kind": "function", "doc": "<p>Nombre: sendUDPDatagram\nDescripci\u00f3n: Esta funci\u00f3n construye un datagrama UDP y lo env\u00eda\nEsta funci\u00f3n debe realizar, al menos, las siguientes tareas:\n    -Construir la cabecera UDP:\n        -El puerto origen lo obtendremos llamando a getUDPSourcePort\n        -El valor de checksum lo pondremos siempre a 0\n    -A\u00f1adir los datos\n    -Enviar el datagrama resultante llamando a sendIPDatagram</p>\n\n<p>Argumentos:\n    -data: array de bytes con los datos a incluir como payload en el datagrama UDP\n    -dstPort: entero de 16 bits que indica el n\u00famero de puerto destino a usar\n    -dstIP: entero de 32 bits con la IP destino del datagrama UDP\nRetorno: True o False en funci\u00f3n de si se ha enviado el datagrama correctamente o no</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">data</span>, </span><span class=\"param\"><span class=\"n\">dstPort</span>, </span><span class=\"param\"><span class=\"n\">dstIP</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "udp.initUDP", "modulename": "udp", "qualname": "initUDP", "kind": "function", "doc": "<p>Nombre: initUDP\nDescripci\u00f3n: Esta funci\u00f3n inicializa el nivel UDP\nEsta funci\u00f3n debe realizar, al menos, las siguientes tareas:\n    -Registrar (llamando a registerIPProtocol) la funci\u00f3n process_UDP_datagram con el valor de protocolo 17</p>\n\n<p>Argumentos:\n    -Ninguno\nRetorno: Ninguno</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">):</span></span>", "funcdef": "def"}];

    // mirrored in build-search-index.js (part 1)
    // Also split on html tags. this is a cheap heuristic, but good enough.
    elasticlunr.tokenizer.setSeperator(/[\s\-.;&_'"=,()]+|<[^>]*>/);

    let searchIndex;
    if (docs._isPrebuiltIndex) {
        console.info("using precompiled search index");
        searchIndex = elasticlunr.Index.load(docs);
    } else {
        console.time("building search index");
        // mirrored in build-search-index.js (part 2)
        searchIndex = elasticlunr(function () {
            this.pipeline.remove(elasticlunr.stemmer);
            this.pipeline.remove(elasticlunr.stopWordFilter);
            this.addField("qualname");
            this.addField("fullname");
            this.addField("annotation");
            this.addField("default_value");
            this.addField("signature");
            this.addField("bases");
            this.addField("doc");
            this.setRef("fullname");
        });
        for (let doc of docs) {
            searchIndex.addDoc(doc);
        }
        console.timeEnd("building search index");
    }

    return (term) => searchIndex.search(term, {
        fields: {
            qualname: {boost: 4},
            fullname: {boost: 2},
            annotation: {boost: 2},
            default_value: {boost: 2},
            signature: {boost: 2},
            bases: {boost: 2},
            doc: {boost: 1},
        },
        expand: true
    });
})();